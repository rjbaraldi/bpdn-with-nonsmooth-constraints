/*
  The default CurveLab's FFTW Functions. All fftw information is included in this file. This allows for expanding and updating FFTW lib and replacing the FFTW function with optimizations and improvments.  The default function used a planmap optimization for the FFTW info in the sepangle and invsep functions.
*/

#include "fdct3d.hpp"
#include "fdct3dinline.hpp"
#include "fftw.h"

typedef pair<int,int> intpair;  typedef pair<int, intpair> inttriple;
map<inttriple, fftwnd_plan> planmap;

int fdct3d_fft(CpxNumTns& x, CpxOffTns& O, bool inv)
{
  if(inv)
  {
  	//Create the Backward FFTW transformation function.  It should take a OffMat and return a NumMat.
        int N1 = O.m();		int N2 = O.n();		int N3 = O.p();

	CpxNumTns T(N1,N2,N3);
	fdct3d_ifftshift(N1,N2,N3,O,T);
	fftwnd_plan p = fftw3d_create_plan(N3, N2, N1, FFTW_BACKWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
	fftwnd_destroy_plan(p);
	double sqrtprod = sqrt(double(N1*N2*N3)); //scale
	for(int i=0; i<N1; i++)	 for(int j=0; j<N2; j++)		for(int k=0; k<N3; k++)		  T(i,j,k) /= sqrtprod;
	
	x = T;
  } else
  {
  	//Create the Forward FFTW transformation function.  It should take a NumMat and return a OffMat.
        int N1 = x.m();		int N2 = x.n();		int N3 = x.p();
  	//------------------------------------------------------------
	CpxNumTns T(x);
	fftwnd_plan p = fftw3d_create_plan(N3, N2, N1, FFTW_FORWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
	double sqrtprod = sqrt(double(N1*N2*N3));  for(int i=0; i<N1; i++)	 for(int j=0; j<N2; j++)		for(int k=0; k<N3; k++)		  T(i,j,k) /= sqrtprod;
	fftwnd_destroy_plan(p);
	O.resize(N1, N2, N3);
	fdct3d_fftshift(N1, N2, N3, T, O);
  }  
  return 0;
}

//This fft2 function usally does the same as the first function and thus can just call it.  If you have a specific task for the FFTW in the sepangle/wavelet functions you can add special optimizations here.
int fdct3d_fft2(CpxNumTns& x, CpxOffTns& O, bool inv)
{
  if(inv)
  {
  	//Create the Backward fftw transformation function.  It should take a OffMat and return a NumMat.
  	int xn = O.m();		int yn = O.n();		int zn = O.p();
  	//------------------------------------------------------------
	CpxNumTns tpdata(xn,yn,zn);
	fdct3d_ifftshift(xn,yn,zn,O,tpdata);
	fftwnd_plan p = NULL;
	map<inttriple, fftwnd_plan>::iterator mit = planmap.find( inttriple(xn, intpair(yn,zn)) );
	if(mit!=planmap.end()) {			 p = (*mit).second;
	} else {
		p = fftw3d_create_plan(zn, yn, xn, FFTW_BACKWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
		planmap[ inttriple(xn, intpair(yn,zn)) ] = p;
	}
	fftwnd_one(p, (fftw_complex*)tpdata.data(), NULL);		  //cerr<<"wedge s"<<endl;
	double sqrtprod = sqrt(double(xn*yn*zn));		  for(int i=0; i<xn; i++)			 for(int j=0; j<yn; j++)				for(int k=0; k<zn; k++)				  tpdata(i,j,k) /= sqrtprod;
	x = tpdata;
  } else
  {
     	//Create the Forward FFTW transformation function.  It should take a NumMat and return a OffMat.
  	int xn = x.m();		int yn = x.n();		int zn = x.p();
  	//------------------------------------------------------------
	CpxNumTns tpdata(x);
	fftwnd_plan p = NULL;
	map<inttriple, fftwnd_plan>::iterator mit = planmap.find( inttriple(xn, intpair(yn,zn)) );
	if(mit!=planmap.end()) {			 p = (*mit).second;
	} else {
			 p = fftw3d_create_plan(zn, yn, xn, FFTW_FORWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
			 planmap[ inttriple(xn, intpair(yn,zn)) ] = p;
	}
	fftwnd_one(p, (fftw_complex*)tpdata.data(), NULL);		  //cerr<<"wedge s"<<endl;
	double sqrtprod = sqrt(double(xn*yn*zn));
		  for(int i=0; i<xn; i++)			 for(int j=0; j<yn; j++)				for(int k=0; k<zn; k++)				  tpdata(i,j,k) /= sqrtprod;

	O.resize(xn,yn,zn);
	fdct3d_fftshift(xn,yn,zn,tpdata,O);
  }
  return 0;
}

//this function will clean up the MapPlan optimization.  The MapPlan optimization is not nessasary, and this function can just pass if no optimization is used, or anything global vars has to be cleaned.
int fftw_cleanmap()
{
  for(map<inttriple, fftwnd_plan>::iterator mit=planmap.begin(); mit!=planmap.end(); mit++) {
	 fftwnd_plan p = (*mit).second;
	 fftwnd_destroy_plan(p);
  }
  planmap.clear();
  return 0;
}
