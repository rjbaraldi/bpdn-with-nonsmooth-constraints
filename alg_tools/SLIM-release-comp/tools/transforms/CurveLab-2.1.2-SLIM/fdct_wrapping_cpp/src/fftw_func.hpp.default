/*
  The default CurveLab's FFTW Functions. All fftw information is included in this file. This allows for expanding and updating FFTW lib and replacing the FFTW function with optimizations and improvments.  The default function used a planmap optimization for the FFTW info in the sepangle and invsep functions.
*/

#include "fdct_wrapping.hpp"
#include "fdct_wrapping_inline.hpp"
#include "fftw.h"

FDCT_WRAPPING_NS_BEGIN_NAMESPACE

typedef pair<int,int> intpair;
map<intpair, fftwnd_plan> planmap;

int fdct_wrapping_fft(CpxNumMat& x, CpxOffMat& O, bool inv)
{
  if(inv)
  {
  	//Create the Backward FFTW transformation function.  It should take a OffMat and return a NumMat.
  	int N1 = O.m();		int N2 = O.n();

  	CpxNumMat T(N1,N2);
  	fdct_wrapping_ifftshift(O, T);
  	fftwnd_plan p = fftw2d_create_plan(N2, N1, FFTW_BACKWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
  	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
  	fftwnd_destroy_plan(p);
  	double sqrtprod = sqrt(double(N1*N2)); //scale
  	for(int i=0; i<N1; i++)	 for(int j=0; j<N2; j++)	 T(i,j) /= sqrtprod;

  	x = T;
  } else
  {
  	//Create the Forward FFTW transformation function.  It should take a NumMat and return a OffMat.
  	int N1 = x.m();		int N2 = x.n();
  	//------------------------------------------------------------
  	CpxNumMat T(x);
  	fftwnd_plan p = fftw2d_create_plan(N2, N1, FFTW_FORWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
  	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
  	fftwnd_destroy_plan(p);
  	double sqrtprod = sqrt(double(N1*N2));
  	for(int j=0; j<N2; j++)	 for(int i=0; i<N1; i++)		T(i,j) /= sqrtprod;

  	O.resize(N1, N2);
  	fdct_wrapping_fftshift(T, O);
  }  
  return 0;
}

//This fft2 function usally does the same as the first function and thus can just call it.  If you have a specific task for the FFTW in the sepangle/wavelet functions you can add special optimizations here.
int fdct_wrapping_fft2(CpxNumMat& x, CpxOffMat& O, bool inv)
{
  if(inv)
  {
  	//Create the Backward fftw transformation function.  It should take a OffMat and return a NumMat.
  	int N1 = O.m();		int N2 = O.n();
  	//------------------------------------------------------------
  	CpxNumMat T(N1, N2);
  	fdct_wrapping_ifftshift(O, T);

  	fftwnd_plan p = NULL;
  	map<pair<int,int>,fftwnd_plan>::iterator mit=planmap.find( pair<int,int>(N1,N2) );
  	if(mit!=planmap.end()) {
		p = (*mit).second;
  	} else {
	 	p = fftw2d_create_plan(N2, N1, FFTW_BACKWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
		 	planmap[ pair<int,int>(N1, N2) ] = p;
		}

  	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
  	double sqrtprod = sqrt(double(N1*N2));
  	for(int j=0; j<N2; j++)		  for(int i=0; i<N1; i++)			T(i,j) /= sqrtprod;
  	
  	x = T;
  } else
  {
  	//Create the Forward FFTW transformation function.  It should take a NumMat and return a OffMat.
  	int N1 = x.m();		int N2 = x.n();
  	//------------------------------------------------------------
  	CpxNumMat T(x);
	fftwnd_plan p = NULL;
	map<pair<int,int>, fftwnd_plan>::iterator mit=planmap.find( pair<int,int>(N1,N2) );
	if(mit!=planmap.end()) {
			p = (*mit).second;
	} else {
		p = fftw2d_create_plan(N2, N1, FFTW_FORWARD, FFTW_ESTIMATE | FFTW_IN_PLACE);
		planmap[ pair<int,int>(N1, N2) ] = p;
	}
	fftwnd_one(p, (fftw_complex*)T.data(), NULL);
	double sqrtprod = sqrt(double(N1*N2));
	for(int j=0; j<N2; j++)	 for(int i=0; i<N1; i++)		T(i,j) /= sqrtprod;
	
	O.resize(N1, N2);
	fdct_wrapping_fftshift(T,O);
  }  	
  return 0;
}

//this function will clean up the MapPlan optimization.  The MapPlan optimization is not nessasary, and this function can just pass if no optimization is used, or anything global vars has to be cleaned.
int fftw_cleanmap()
{
  for(map<intpair, fftwnd_plan>::iterator mit=planmap.begin(); mit!=planmap.end(); mit++) {
    fftwnd_plan p = (*mit).second;
    fftwnd_destroy_plan(p);
  }
  planmap.clear();
  return 0;
}

FDCT_WRAPPING_NS_END_NAMESPACE
